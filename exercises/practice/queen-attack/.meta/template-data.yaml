methods: is-attack
properties:
  create:
    test: |-
      if %case<expected><error>:exists {
        sprintf(q:to/END/, (%case<input><queen><position><row>, %case<input><queen><position><column>, %case<expected><error>, %case<description>).map(*.raku));
        throws-like(
          { QueenAttack.new( :row(%s), :column(%s) ) },
          Exception,
          message => /:i
              %s
              || "type check failed"
          /,
          %s,
        );
        END
      } else {
        sprintf(q:to/END/, (%case<input><queen><position><row>, %case<input><queen><position><column>, %case<description>).map(*.raku));
        try {
          my $QA = QueenAttack.new( :row(%s), :column(%s) );
        } // fail %s;
        END
      }

  canAttack:
    test: |-
      sprintf(q:to/END/, (%case<input><white_queen><position><row>, %case<input><white_queen><position><column>, %case<input><black_queen><position><row>, %case<input><black_queen><position><column>, %case<expected>, %case<description>).map(*.raku));
      cmp-ok(
        QueenAttack.new( :row(%s), :column(%s) ).is-attack( :row(%s), :column(%s) ),
        &infix:<==>,
        %s,
        %s,
      );
      END

unit: class
example: |-
  has Int() ($.row where 0..7, $.column where 0..7);

  method is-attack (:$row, :$column --> Bool() ) {
      with cache map { .head, .tail }, ($.row, $.column), ($row, $column) {
             when    [eqv]                 .list { fail  } # Same square
             when    [==] map *.head,      .list           # Same file
                  or [==] map *.tail,      .list           # Same rank
                  or [==] map *.abs , [Z-] .list { True  } # Same diagonal
          default                                { False }
      }
  }

stub: |-
  has ($.row, $.column);

  method is-attack (:$row, :$column) {
      return self;
  }
