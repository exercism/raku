package: Queen
methods: can-attack
properties:
  create:
    test: |-
      if %case<expected><error>:exists {
        sprintf(q:to/END/, (%case<input><queen><position><row>, %case<input><queen><position><column>, %case<expected><error>, %case<description>).map(*.raku));
        throws-like(
          { Queen.new( :row(%s), :column(%s) ) },
          Exception,
          message => /:i
              %s
              || "type check failed"
          /,
          %s,
        );
        END
      } else {
        sprintf(q:to/END/, (%case<input><queen><position><row>, %case<input><queen><position><column>, %case<description>).map(*.raku));
        lives-ok(
            { Queen.new( :row(%s), :column(%s) ) },
            %s,
        );
        END
      }

  canAttack:
    test: |-
      sprintf(q:to/END/, (%case<input><white_queen><position><row>, %case<input><white_queen><position><column>, %case<input><black_queen><position><row>, %case<input><black_queen><position><column>).map(*.raku), %case<expected>, %case<description>.map(*.raku));
      cmp-ok(
        Queen.new( :row(%s), :column(%s) ).can-attack( :row(%s), :column(%s) ),
        &infix:<eqv>,
        %s,
        %s,
      );
      END

unit: class
example: |-
  has Int() ($.row where 0..7, $.column where 0..7);

  method can-attack (:$row, :$column --> Bool() ) {
      with cache map { .head, .tail }, ($.row, $.column), ($row, $column) {
             when    [eqv]                 .list { fail  } # Same square
             when    [==] map *.head,      .list           # Same file
                  or [==] map *.tail,      .list           # Same rank
                  or [==] map *.abs , [Z-] .list { True  } # Same diagonal
          default                                { False }
      }
  }

stub: |-
  has ($.row, $.column);

  method can-attack (:$row, :$column) {
  }
