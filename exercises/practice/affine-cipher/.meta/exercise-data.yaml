methods: encode decode
properties:
  encode:
    test: |-
      if %case<expected><error>:exists {
          sprintf(q:to/END/, (|(%case<input><key><a b>:p), %case<description>).map(*.raku));
          dies-ok { AffineCipher.new( %s, %s ) }, %s;
          END
      }
      else {
          sprintf(q:to/END/, (|(%case<input><key><a b>:p), %case<input><phrase>, |(%case<expected description>)).map(*.raku));
          is(
              AffineCipher.new( %s, %s ).encode(%s),
              %s,
              %s,
          );
          END
      }
  decode:
    test: |-
      if %case<expected><error>:exists {
          sprintf(q:to/END/, (|(%case<input><key><a b>:p), %case<description>).map(*.raku));
          dies-ok { AffineCipher.new( %s, %s ) }, %s;
          END
      }
      else {
          sprintf(q:to/END/, (|(%case<input><key><a b>:p), %case<input><phrase>, |(%case<expected description>)).map(*.raku));
          is(
              AffineCipher.new( %s, %s ).decode(%s),
              %s,
              %s,
          );
          END
      }

unit: class
example: |-
  has $.a;
  has $.b;
  has @!letters = ('a'..'z');
  has $!m       = @!letters.elems;

  method encode ($phrase) {
      return $phrase;
  }

  method decode ($phrase) {
      return $phrase;
  }

  submethod TWEAK {
      for 2..$!a {
          die if ($!a & $!m) %% $_;
      }
  }

stub: |-
  has $.a;
  has $.b;
  has @!letters = ('a'..'z');
  has $!m       = @!letters.elems;

  method encode ($phrase) {
  }

  method decode ($phrase) {
  }
