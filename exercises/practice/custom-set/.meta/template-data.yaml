package: CustomSet

tests: |
  my CustomSet $ensemble;

properties:
  empty:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set>.Set, %case<expected>, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).is-empty,
          'eqv',
          %s,
          %s,
        );
        END
  contains:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set>.Set, %case<input><element>.Int, %case<expected>, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).contains(%s),
          'eqv',
          %s,
          %s,
        );
        END
  subset:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set1>.Set, %case<input><set2>.Set, %case<expected>, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).has-subset(%s),
          'eqv',
          %s,
          %s,
        );
        END
  disjoint:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set1>.Set, %case<input><set2>.Set, %case<expected>, %case<description>);
      cmp-ok(
        $ensemble.new(elements => %s).is-disjoint(%s),
        'eqv',
        %s,
        %s,
      );
      END
  equal:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set1>.Set, %case<input><set2>.Set, %case<expected>, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).is-equal(%s),
          'eqv',
          %s,
          %s,
        );
        END
  add:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set>.Set, %case<input><element>.Int, %case<expected>.Set, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).add(%s),
          'eqv',
          %s,
          %s,
        );
        END
  intersection:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set1>.Set, %case<input><set2>.Set, %case<expected>.Set, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).intersection(%s),
          'eqv',
          %s,
          %s,
        );
        END
  difference:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set1>.Set, %case<input><set2>.Set, %case<expected>.Set, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).compliment(%s),
          'eqv',
          %s,
          %s,
        );
        END
  union:
    test: |-
      sprintf(q:to/END/, map *.raku, %case<input><set1>.Set, %case<input><set2>.Set, %case<expected>.Set, %case<description>);
        cmp-ok(
          $ensemble.new(elements => %s).union(%s),
          'eqv',
          %s,
          %s,
        );
        END

unit: class
example: |-
  has Set $.elements;

  method is-empty {
    self.elements eqv ∅
  }
  method contains ($element) {
    $element ∈ self.elements
  }
  method has-subset ($set) {
    self.elements ⊆ $set 
  }
  method is-disjoint ($set) {
    self.intersection($set) eqv ∅
  }
  method is-equal ($set) {
    self.elements ≡ $set
  }
  method add ($set) {
    $!elements ∪= $set
  }
  method intersection ($set) {
    $!elements ∩= $set
  }
  method compliment ($set) {
    self.elements ∖ $set
  }
  method union ($set) {
    self.add($set)
  }

stub: |-
  has Set $.elements;

  method is-empty {
  }
  method contains ($element) {
  }
  method has-subset ($set)  {
  }
  method is-disjoint ($set) {
  }
  method is-equal ($set) {
  }
  method add ($element) {
  }
  method intersection ($set) {
  }
  method compliment ($set) {
  }
  method union ($set) {
  }

