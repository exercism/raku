unit: false
tests: |
  my Bowling $game;

properties:
  roll:
    test: |-
      my Str $prev = '$game.=new;' ~ "\n";
      if %case<input><previousRolls> {
        $prev ~= sprintf(q:to/END/, %case<input><previousRolls><>.List.raku);
        for %s -> $pins {
            $game.roll($pins);
        }
        END
      }
      my $error = do given %case<expected><error> {
          when /^Pin/    {'X::Bowling::TooManyPins'}
          when /^Cannot/ {'X::Bowling::GameOver'}
          when /^Neg/    {'X::Bowling::NegativePins'}
      }
      $prev ~ sprintf(q:to/END/, %case<input><roll>, $error, %case<description>.raku, %case<expected><error>.raku);
      throws-like(
          { $game.roll(%s) },
          %s,
          %s,
          :message(/^ %s $/),
      );
      END
  score:
    test: |-
      my Str $prev = '$game.=new;' ~ "\n";
      if %case<input><previousRolls> {
        $prev ~= sprintf(q:to/END/, %case<input><previousRolls><>.List.raku);
        for %s -> $pins {
            $game.roll($pins);
        }
        END
      }
      if %case<expected><error>:exists {
          my $error = do given %case<expected><error> {
              when /^Score/  {'X::Bowling::GameInProgress'}
          }
          $prev ~ sprintf(q:to/END/, $error, %case<description>.raku, %case<expected><error>.raku);
          throws-like(
              { $game.score },
              %s,
              %s,
              :message(/^ %s $/),
          );
          END
      }
      else {
          $prev ~ sprintf(q:to/END/, %case<expected>, %case<description>.raku);
          cmp-ok(
              $game.score,
              "==",
              %s,
              %s,
          );
          END
      }


example: |-
  my class X::Bowling::GameOver is Exception {
      method message {'Cannot roll after game is over'}
  }

  my class X::Bowling::GameInProgress is Exception {
      method message {'Score cannot be taken until the end of the game'}
  }

  my class X::Bowling::TooManyPins is Exception {
      method message {'Pin count exceeds pins on the lane'}
  }

  my class X::Bowling::NegativePins is Exception {
      method message {'Negative roll is invalid'}
  }

  class Bowling {
      my class Frame {
          has @.rolls is List;
          has Bool:D $.is-final = False;
          has UInt:D $!max-roll = 10;
          
          multi method add-roll (UInt:D $pins where $pins > $!max-roll) {
              X::Bowling::TooManyPins.new.throw;
          }

          multi method add-roll (UInt:D $pins) {
              if $.is-final {
                  if @.rolls == 2 {
                      $!max-roll = 0;
                  }
                  elsif @.rolls == 1 && @.rolls[0] != 10 {
                      $!max-roll = @.rolls[0] + $pins == 10 ?? 10 !! 0;
                  }
                  elsif @.rolls == 1 && @.rolls[0] == 10 && $pins < 10 {
                      $!max-roll -= $pins;
                  }
              }
              elsif !@.rolls {
                  $!max-roll -= $pins;
              }
              elsif @.rolls == 1 {
                  $!max-roll = 0;
              }

              @!rolls := |@!rolls, $pins;
          }

          method is-strike {
              return Nil if $.is-final || $.is-complete.not;
              return @.rolls == 1 && @.rolls[0] == 10;
          }

          method is-spare {
              return Nil if $.is-final || $.is-complete.not;
              return @.rolls == 2 && @.rolls.sum == 10;
          }

          method is-complete {
              return $!max-roll == 0;
          }
      }

      has Frame @!frames = Frame.new;

      multi method roll ($pins where * < 0) {
          X::Bowling::NegativePins.new.throw;
      }

      multi method roll ($pins) {
          X::Bowling::GameOver.new.throw if $.is-complete;

          given @!frames[*-1] -> $current-frame {
              if !$current-frame.is-final && $current-frame.rolls[0].defined && $current-frame.rolls[0] + $pins > 10 {
                  X::Bowling::TooManyPins.new.throw;
              }

              $current-frame.add-roll($pins);
              if $current-frame.is-complete && $current-frame.is-final.not {
                  @!frames.push(Frame.new(:is-final(@!frames.elems == 9)));
              }
          }
      }

      method score {
          X::Bowling::GameInProgress.new.throw unless $.is-complete;

          return sum gather {
              for ^@!frames -> $i {
                  .take for @!frames[$i].rolls;

                  unless @!frames[$i].is-final {
                      when @!frames[$i].is-strike {
                          if @!frames[$i+1].is-final {
                              .take for @!frames[$i+1].rolls[^2];
                          }
                          else {
                              .take for @!frames[$i+1].rolls;
                          }
                          take @!frames[$i+2].rolls[0] if @!frames[$i+1].rolls == 1;
                      }

                      when @!frames[$i].is-spare {
                          take @!frames[$i+1].rolls[0];
                      } 
                  }
              }
          }
      }

      method is-complete {
          return @!frames[*-1].is-final && @!frames[*-1].is-complete;
      }
  }

stub: |-
  my class X::Bowling::GameOver is Exception {
      method message {'Cannot roll after game is over'}
  }

  my class X::Bowling::GameInProgress is Exception {
      method message {'Score cannot be taken until the end of the game'}
  }

  my class X::Bowling::TooManyPins is Exception {
      method message {'Pin count exceeds pins on the lane'}
  }

  my class X::Bowling::NegativePins is Exception {
      method message {'Negative roll is invalid'}
  }

  class Bowling {
      method roll ($pins) {
      }

      method score {
      }
  }
